#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Author: Kevin Lamkiewicz
# E-Mail: kevin.lamkiewicz@uni-jena.de

"""
This script is part of the publication
"TODO -- Insert Title here"
by Jonas Fuchs et al. 2020

SNP information generated by lofreq are taken and parsed into configuration files for 
circos plotting.

"""

##################
# import section #
##################

import sys
import math
import csv
import re
import pysam

#######################
# auxiliary functions #
#######################

def read_reference(fastaFile):
    """
    Read the reference file in .fasta format.

    Nothing fancy going on here, just a small read.
    Further, all dictionaries and data structures are
    initialized here with the length of each segment.
    -----------------------------------------------------
    Keyword arguments:
    fastaFile -- Path to the reference file.
    """

    with open(fastaFile, 'r') as inputStream:
      header = ''
      seq = ''

      for line in inputStream:
        if line.startswith(">"):
          if header:
            chromosomes[header] = seq
          header = line.rstrip("\n").replace(':','_').replace(' ','_').lstrip(">")
          seq = ''
        else:
          seq += line.rstrip("\n").upper()
      chromosomes[header] = seq

    # init all data structures for further calculations
    for chromosome, sequence in chromosomes.items():
      length = len(sequence)
      
      positionSNPs[chromosome] = [0 for pos in range(length)]
      coverages[chromosome] = [0 for pos in range(length)]
      snpAllele[chromosome] = {i : dict(zip(validNTs,[0,0,0,0])) for i in range(length)}

def count_coverage():
  """
  Each read in the mapping file gets corrected based on the CIGAR
  string. This is done rather naive, (see correct_read_cigar()).
  Then, for each aligned position, the coverage gets increased
  by one. 
  """

  i = 0
  for read in read_mapping(mappingFile):
    refChr = read.reference_name
    #tmpRead = read
    read = str(read).strip("\n").split("\t")

    correctedRead = correct_read_cigar(read[9], read[5])
    mapped_position = int(read[3])
  
    for i in range(mapped_position, mapped_position + len(correctedRead)):
      if correctedRead[i - mapped_position] in validNTs:
        coverages[refChr][i] += 1

def read_mapping(mapping):
  """
  Read individual mapped reads from the alignment file.
  This method utilizies the pysam Python wrapper and
  reads a mapping in either .sam, .bam or .cram format.
  It also used yield in order to save some memory.
  -----------------------------------------------------
  Keyword arguments:
  mapping -- Path to the mapping file.
  """
  if mapping.endswith('bam'):
      in_file = pysam.AlignmentFile(mapping, "rb")
  elif mapping.endswith('sam'):
      in_file = pysam.AlignmentFile(mapping, "r")
  elif mapping.endswith('cram'):
      in_file = pysam.AlignmentFile(mapping, "rc")
  else:
      print("No valid mapping format detected. File has to be SAM/BAM/CRAM")
      sys.exit(1)

  iteration = in_file.fetch(until_eof=True)

  for read in iteration:
      yield (read)

def correct_read_cigar(read_sequence, cigar_string):
  """
  A very simple and naive CIGAR string parser that will correct a given 'read_sequence' for
  insertion and deletions. Hard clippings are completely discarded in the resulting read.
  Insertions and Soft-Clipping are deleted from the corrected read, whereas Deletions and Splice-Sites
  will introduce a 'N' to the corresponding position.
  -----------------------------------------------------------------------
  Keyword arguments:
  read_sequence -- the sequence of a mapped read
  cigar_string -- corresponding CIGAR string of the mapped read
  """
  position = 0

  for match in regex.finditer(cigar_string):
      length, cigar_operation = match.groups()
      length = int(length)

      if cigar_operation == 'H':
          continue

      if cigar_operation == 'I' or cigar_operation == 'S':
          read_sequence = read_sequence[
              :position] + read_sequence[position + length:]
          continue

      if cigar_operation == 'D' or cigar_operation == 'N':
          read_sequence = read_sequence[
              :position] + ('N' * length) + read_sequence[position:]
      position += length
  return (read_sequence)

def read_snp_file(snpFile):
  """
  Uses the csv module to read in the SNP summary file. 
  All values are parsed and the relative amount of SNPs per position 
  are transformed with the math.log10() function.

  Note: as lofreq doesn't report SNPs with coverage '0', the log function
  won't fail in this particular case.
  -----------------------------------------------------------------------
  Keyword arguments:
  snpFile -- path to the .csv file containing the SNP information
  """
  
  with open(snpFile, 'r') as inputStream:
      reader = csv.reader(inputStream, delimiter="\t")
      for row in reader:
        segment = row[0][-1]
        position = row[1]
        relSNP = float(row[5])*100
        relSNP = math.log10(relSNP)
        
        if segment in positionSNPs:
          positionSNPs[segment].update({position : relSNP})
        else:
          positionSNPs[segment] = {position : relSNP}
  

###############
# MAIN METHOD #
###############

if __name__ == "__main__":
  # global variable definitions
  d_mappings = {}
  regex = re.compile(r'(\d+)([A-Z])')

  coverages = {}
  positionSNPs = {}
  snpAllele = {}
  chromosomes = {}
  validNTs = ['A','C','G','T']

  snpFile = sys.argv[1]
  reference = sys.argv[2]
  mappingFile = sys.argv[3]
  outputDir = sys.argv[4]
  basename = snpFile.split('/')[-1]
  basename = '_'.join(basename.split('_')[:3])
  
  # check whether we are looking for jos or 
  # kami virus. This is crucial for the correct
  # circos plot.
  if "jos" in snpFile.lower():
    strain = "jos"
  elif "kami" in snpFile.lower():
    strain = "kami"
  else:
    print("Don't recognize virus.", file=sys.stderr)
    sys.exit(1)

  # read in reference and initialize 
  # coverage and SNP dicts
  read_reference(reference)
  count_coverage()
  read_snp_file(snpFile)
  

  with open(f"{outputDir}/{basename}_cov.txt",'w') as covFileStream:
    with open(f"{outputDir}/{basename}_snp.txt",'w') as snpFileStream:

      for chromosome, sequence in chromosomes.items():
        for pos in range(len(sequence)):
          seg = chromosome[-1]
          coverage = coverages[chromosome][pos]
          if coverage == 0:
            # I use the -3 as lowest value for the plots, since math.log(0)
            # won't work.
            coverage = 0.001
          coverage = math.log10(coverage)

          # str(pos+1) is due to parsing and counting issues...
          if seg in positionSNPs and str(pos+1) in positionSNPs[seg]:
            relSNP = positionSNPs[seg][str(pos+1)]
          else:
            # I use the -3 as lowest value for the plots, since math.log(0)
            # won't work.
            relSNP = math.log10(0.001)

          covFileStream.write(f"{strain}{seg} {pos+1} {pos+1} {coverage}\n")
          snpFileStream.write(f"{strain}{seg} {pos+1} {pos+1} {relSNP}\n")